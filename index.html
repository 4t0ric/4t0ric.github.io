<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake Game</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: black;
      color: white;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #score {
      position: fixed;
      top: 10px;
      left: 10px;
      font-size: 20px;
      z-index: 10;
    }
    #game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 30px;
      color: red;
      display: none;
      z-index: 20;
      text-align: center;
    }
    .btn {
      padding: 8px 12px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      margin: 5px;
    }
    #toggle-grid, #settings-button {
      position: fixed;
      top: 10px;
      z-index: 10;
    }
    #toggle-grid {
      right: 10px;
    }
    #settings-button {
      right: 120px;
    }
    #settings-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px;
      background: rgba(0,0,0,0.9);
      border-radius: 10px;
      display: none;
      z-index: 30;
      min-width: 200px;
    }
    #settings-modal button {
      width: 100%;
    }
    label {
      display: block;
      margin-top: 10px;
      font-size: 16px;
    }
    select {
      width: 100%;
      padding: 5px;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <button id="settings-button" class="btn">⚙️</button>
  <button id="toggle-grid" class="btn">Toggle Grid</button>
  <div id="settings-modal">
    <label>Difficulty:
      <select id="difficulty">
        <option value="150">Easy</option>
        <option value="100" selected>Medium</option>
        <option value="60">Hard</option>
      </select>
    </label>
    <button id="theme-toggle" class="btn">Toggle Theme</button>
    <button id="close-settings" class="btn">Close</button>
  </div>
  <div id="game-over">Game Over!<br />Press R or Tap to Restart</div>
  <canvas id="game"></canvas>

  <script>
    (() => {
      const CELL_SIZE = 20;
      let canvas, ctx, width, height, columns, rows;
      let snake, direction, food, foodIsPowerup;
      let powerupActive = false, powerupEndTime = 0;
      let snakeColor = "green", score = 0, gameOver = false;
      let showGrid = true, darkTheme = true;
      let updateDelay = 100, updateInterval;

      const POWERUP_DURATION = 10000;
      const scoreDiv = document.getElementById("score");
      const gameOverDiv = document.getElementById("game-over");
      const settingsBtn = document.getElementById("settings-button");
      const settingsModal = document.getElementById("settings-modal");
      const themeBtn = document.getElementById("theme-toggle");
      const difficultySelect = document.getElementById("difficulty");

      function init() {
        canvas = document.getElementById("game");
        ctx = canvas.getContext("2d");
        resize();
        resetGame();
        window.addEventListener("resize", resize);
        window.addEventListener("keydown", keyDownHandler);
        canvas.addEventListener("click", () => { if (gameOver) resetGame(); });
        settingsBtn.onclick = () => settingsModal.style.display = "block";
        document.getElementById("close-settings").onclick = () => settingsModal.style.display = "none";
        document.getElementById("toggle-grid").onclick = () => { showGrid = !showGrid; draw(); };
        themeBtn.onclick = toggleTheme;
        difficultySelect.onchange = () => {
          updateDelay = parseInt(difficultySelect.value);
          clearInterval(updateInterval);
          updateInterval = setInterval(update, updateDelay);
        };

        initSwipeControls();

        updateInterval = setInterval(update, updateDelay);
      }

      function toggleTheme() {
        darkTheme = !darkTheme;
        document.body.style.background = darkTheme ? "black" : "#f4f4f4";
        document.body.style.color = darkTheme ? "white" : "black";
        settingsModal.style.background = darkTheme ? "rgba(0,0,0,0.9)" : "#ffffff";
        settingsModal.style.color = darkTheme ? "white" : "black";
        const buttons = settingsModal.querySelectorAll(".btn");
        buttons.forEach(btn => {
          btn.style.background = darkTheme ? "white" : "#222";
          btn.style.color = darkTheme ? "black" : "white";
        });
        snakeColor = darkTheme ? "green" : "#007700";
        draw();
      }

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        columns = Math.floor(width / CELL_SIZE);
        rows = Math.floor(height / CELL_SIZE);
      }

      function resetGame() {
        snakeColor = darkTheme ? "green" : "#007700";
        powerupActive = false;
        powerupEndTime = 0;
        gameOver = false;
        score = 0;
        direction = "Right";
        snake = [
          {x: Math.floor(columns/2), y: Math.floor(rows/2)},
          {x: Math.floor(columns/2) - 1, y: Math.floor(rows/2)},
          {x: Math.floor(columns/2) - 2, y: Math.floor(rows/2)}
        ];
        placeFood();
        scoreDiv.textContent = "Score: " + score;
        gameOverDiv.style.display = "none";
      }

      function placeFood() {
        while (true) {
          let x = Math.floor(Math.random() * columns);
          let y = Math.floor(Math.random() * rows);
          if (!snake.some(seg => seg.x === x && seg.y === y)) {
            food = {x, y};
            foodIsPowerup = Math.random() < 0.05;
            break;
          }
        }
      }

      function keyDownHandler(e) {
        if (gameOver && (e.key === "r" || e.key === "R")) {
          resetGame();
          return;
        }
        const dir = e.key.replace("Arrow", "");
        const opposites = {Up: "Down", Down: "Up", Left: "Right", Right: "Left"};
        if (["Up", "Down", "Left", "Right"].includes(dir) && opposites[dir] !== direction) {
          direction = dir;
        }
      }

      function update() {
        if (gameOver) return;

        if (powerupActive && Date.now() > powerupEndTime) {
          powerupActive = false;
          snakeColor = darkTheme ? "green" : "#007700";
        }

        let head = {...snake[0]};
        switch(direction) {
          case "Right": head.x += 1; break;
          case "Left": head.x -= 1; break;
          case "Up": head.y -= 1; break;
          case "Down": head.y += 1; break;
        }

        if (head.x < 0 || head.x >= columns || head.y < 0 || head.y >= rows || snake.some(seg => seg.x === head.x && seg.y === head.y)) {
          endGame();
          return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score++;
          if (foodIsPowerup) activatePowerup();
          placeFood();
          scoreDiv.textContent = "Score: " + score;
        } else {
          snake.pop();
        }

        draw();
      }

      function activatePowerup() {
        powerupActive = true;
        snakeColor = "orange";
        powerupEndTime = Date.now() + POWERUP_DURATION;
      }

      function drawCell(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.strokeStyle = "black";
        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }

      function drawGrid() {
        ctx.strokeStyle = darkTheme ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.05)";
        for (let x = 0; x < columns; x++) {
          ctx.beginPath();
          ctx.moveTo(x * CELL_SIZE, 0);
          ctx.lineTo(x * CELL_SIZE, height);
          ctx.stroke();
        }
        for (let y = 0; y < rows; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL_SIZE);
          ctx.lineTo(width, y * CELL_SIZE);
          ctx.stroke();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);
        if (showGrid) drawGrid();
        drawCell(food.x, food.y, foodIsPowerup ? "orange" : "red");
        snake.forEach((seg, i) => drawCell(seg.x, seg.y, i === 0 ? "lime" : snakeColor));
      }

      function endGame() {
        gameOver = true;
        gameOverDiv.style.display = "block";
      }

      function initSwipeControls() {
        let touchStartX = 0, touchStartY = 0;
        canvas.addEventListener("touchstart", e => {
          const t = e.touches[0];
          touchStartX = t.clientX;
          touchStartY = t.clientY;
        });
        canvas.addEventListener("touchmove", e => {
          if (!touchStartX || !touchStartY) return;
          const t = e.touches[0];
          const dx = t.clientX - touchStartX;
          const dy = t.clientY - touchStartY;
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 20 && direction !== "Left") direction = "Right";
            else if (dx < -20 && direction !== "Right") direction = "Left";
          } else {
            if (dy > 20 && direction !== "Up") direction = "Down";
            else if (dy < -20 && direction !== "Down") direction = "Up";
          }
          touchStartX = 0;
          touchStartY = 0;
        });
      }

      init();
    })();
  </script>
</body>
</html>
