<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width,initial-scale=1" />
<title>Snake Game ‚Äî Fixed</title>
<style>
  :root{
    --bg-dark:#000; --bg-light:#f4f4f4; --text-dark:#fff; --text-light:#111;
    --btn-bg-dark:#222; --btn-bg-light:#ddd; --btn-text-dark:#eee; --btn-text-light:#111;
  }
  html,body{height:100%; margin:0;}
  body{
    margin:0; font-family:Arial,Helvetica,sans-serif;
    background:var(--bg-dark); color:var(--text-dark); overflow:hidden;
  }
  #score{position:fixed; left:10px; top:10px; z-index:20; font-size:20px; user-select:none;}
  #highscore{position:fixed; left:10px; top:40px; z-index:20; font-size:16px; user-select:none;}
  #game-over{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    font-size:32px; color:red; text-align:center; z-index:30; display:none; user-select:none; cursor:pointer;
  }
  #powerup-bar-container{
    position:fixed; left:10px; top:70px; width:200px; height:20px;
    background:#444; border-radius:8px; overflow:hidden; z-index:20; display:none;
  }
  #powerup-bar{width:100%; height:100%; background:orange; transition:width 0.1s linear, background-color 0.2s;}
  #settings-btn,#achievements-btn,#credits-btn{
    position:fixed; top:10px; padding:6px 12px; font-size:18px; z-index:25; border-radius:8px; border:none; cursor:pointer;
    background:var(--btn-bg-dark); color:var(--btn-text-dark);
  }
  #settings-btn{ right:10px; }
  #achievements-btn{ right:140px; }
  #credits-btn{ right:270px; }
  #settings-btn:hover,#achievements-btn:hover,#credits-btn:hover{ background:var(--btn-text-dark); color:var(--btn-bg-dark); }
  .modal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(0.95);
    min-width:260px; padding:16px; border-radius:12px; box-shadow:0 8px 40px rgba(0,0,0,0.6);
    z-index:40; background:rgba(0,0,0,0.9); color:var(--text-dark); opacity:0; pointer-events:none; transition:0.18s;
  }
  .modal.show{ opacity:1; pointer-events:auto; transform:translate(-50%,-50%) scale(1); }
  .setting-group{ margin-bottom:12px; }
  .setting-group label{ display:block; margin-bottom:6px; font-weight:600; color:inherit; }
  .setting-group button, .setting-group textarea{
    width:100%; padding:8px; border-radius:8px; border:none; font-size:14px; box-sizing:border-box; cursor:pointer;
    background:var(--btn-bg-dark); color:var(--btn-text-dark);
  }
  canvas{ display:block; }
  /* Light theme */
  .light-theme{ background:var(--bg-light); color:var(--text-light); }
  .light-theme #settings-modal, .light-theme #achievements-modal, .light-theme #credits-modal{ background:#fff; color:var(--text-light); box-shadow:0 8px 32px rgba(0,0,0,0.08); }
  .light-theme .setting-group button{ background:var(--btn-bg-light); color:var(--btn-text-light); }
</style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="highscore">Highscore: 0</div>
  <div id="powerup-bar-container"><div id="powerup-bar"></div></div>
  <div id="game-over">Game Over!<br>Tap or press R to Restart</div>

  <button id="settings-btn">‚öôÔ∏è</button>
  <button id="achievements-btn">üèÜ</button>
  <button id="credits-btn">üé¨ Credits</button>

  <!-- Settings -->
  <div id="settings-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="settings-title">
    <div class="setting-group">
      <label for="difficulty">Difficulty</label>
      <button data-speed="150" class="difficulty-btn">Easy</button>
      <button data-speed="100" class="difficulty-btn">Medium</button>
      <button data-speed="70" class="difficulty-btn">Hard</button>
    </div>
    <div class="setting-group">
      <label>Theme</label>
      <button id="theme-toggle">Toggle Dark / Light</button>
    </div>
    <div class="setting-group">
      <label>Grid</label>
      <button id="grid-toggle">Toggle Grid</button>
    </div>
    <div class="setting-group">
      <label>Account Code</label>
      <textarea id="account-code" readonly></textarea>
      <button id="copy-code">Copy Code</button>
      <button id="load-code">Load from Code</button>
    </div>
    <div class="setting-group">
      <button id="close-settings">Close</button>
    </div>
  </div>

  <!-- Achievements -->
  <div id="achievements-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="achievements-title">
    <h3 style="margin:0 0 8px 0;color:inherit">Achievements</h3>
    <div id="achievements-list-modal" style="max-height:200px; overflow:auto; margin-bottom:8px;"></div>
    <button id="close-achievements">Close</button>
  </div>

  <!-- Credits -->
  <div id="credits-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="credits-title" style="overflow:hidden;">
    <h3 style="margin:0 0 8px 0;color:inherit">Credits</h3>
    <div id="credits-scroll" style="position:relative; width:100%; height:180px; overflow:hidden; background:rgba(0,0,0,0.7); border-radius:8px;">
      <div id="credits-names" style="position:absolute; width:100%; text-align:center; font-size:20px; color:gold;"></div>
    </div>
    <button id="close-credits">Close</button>
  </div>

  <canvas id="game"></canvas>

<script>
(() => {
  // --- CONFIG
  const CELL_SIZE = 20;
  const BASE_UPDATE_DELAY = 100; // ms per step (default)
  const POWERUP_DURATIONS = { orange:20000, half:5000, inv:10000, score:10000 };
  // spawn probabilities (must sum <= 1): orange 10%, half 5%, inv 2%, score 1%, rest normal
  const PROB = { orange:0.10, half:0.05, inv:0.02, score:0.01 };

  // --- DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreDiv = document.getElementById('score');
  const highscoreDiv = document.getElementById('highscore');
  const powerupBarContainer = document.getElementById('powerup-bar-container');
  const powerupBar = document.getElementById('powerup-bar');
  const gameOverDiv = document.getElementById('game-over');

  const settingsBtn = document.getElementById('settings-btn');
  const achievementsBtn = document.getElementById('achievements-btn');
  const creditsBtn = document.getElementById('credits-btn');
  const settingsModal = document.getElementById('settings-modal');
  const achievementsModal = document.getElementById('achievements-modal');
  const creditsModal = document.getElementById('credits-modal');
  const themeToggleBtn = document.getElementById('theme-toggle');
  const gridToggleBtn = document.getElementById('grid-toggle');
  const closeSettingsBtn = document.getElementById('close-settings');
  const closeAchievementsBtn = document.getElementById('close-achievements');
  const closeCreditsBtn = document.getElementById('close-credits');
  const difficultyButtons = document.querySelectorAll('.difficulty-btn');
  const accountCodeBox = document.getElementById('account-code');
  const copyCodeBtn = document.getElementById('copy-code');
  const loadCodeBtn = document.getElementById('load-code');
  const creditsNamesDiv = document.getElementById('credits-names');
  const creditsScrollDiv = document.getElementById('credits-scroll');

  // --- CREDITS DATA ---
  // Edit this array to add your custom names!
  const creditsList = [
    "Your Name",
    "Another Name",
    "Special Thanks: Someone Else",
    "Game Design: You",
    "Programming: You",
    "Music: Open Source",
    "Inspired by Classic Snake",
    "Thank you for playing!"
  ];

  let creditsY = 180;
  let creditsAnim = null;

  function showCredits() {
    creditsNamesDiv.innerHTML = creditsList.map(name => `<div>${name}</div>`).join('');
    creditsY = creditsScrollDiv.offsetHeight;
    creditsNamesDiv.style.top = creditsY + "px";
    creditsModal.classList.add('show');
    gamePaused = true; // PAUSE GAME when credits open
    animateCredits();
  }

  function animateCredits() {
    creditsY -= 0.7; // speed
    creditsNamesDiv.style.top = creditsY + "px";
    if (creditsY + creditsNamesDiv.offsetHeight > 0) {
      creditsAnim = requestAnimationFrame(animateCredits);
    } else {
      // Close credits after a short pause
      setTimeout(() => {
        hideCredits();
      }, 1200);
    }
  }

  function hideCredits() {
    creditsModal.classList.remove('show');
    if (creditsAnim) cancelAnimationFrame(creditsAnim);
    gamePaused = false; // RESUME GAME when credits close
  }

  creditsBtn.addEventListener('click', showCredits);
  closeCreditsBtn.addEventListener('click', hideCredits);
  creditsModal.addEventListener('click', function(e){
    if(e.target === creditsModal) hideCredits();
  });

  // --- GAME STATE
  let width = 0, height = 0, columns = 0, rows = 0;
  let snake = [];
  let direction = 'Right', nextDirection = 'Right';
  let food = null, foodIsPowerup = false;
  let score = 0;
  let account = { highscore:0, achievements:{} };
  const achievementScores = [41,50,67,69,100,150,200,250,300,350,400,450,500,];

  // powerup runtime state
  let powerupActive = false, powerupType = "", powerupEndTime = 0;
  let snakeColor = 'green';
  let updateDelay = BASE_UPDATE_DELAY;
  let lastUpdateTime = 0;
  let gameOver = false;
  let gamePaused = false;
  let showGrid = false;
  let scoreMultiplier = 1;
  let invincible = false;

  // --- UTIL
  function encodeAccount(obj){ try { return btoa(JSON.stringify(obj)); } catch { return ''; } }
  function decodeAccount(code){ try { return JSON.parse(atob(code)); } catch { return null; } }
  function saveAccount(){ localStorage.setItem('snakeAccount', JSON.stringify(account)); accountCodeBox.value = encodeAccount(account); highscoreDiv.textContent = 'Highscore: '+account.highscore; }
  function loadAccount(){ const data = localStorage.getItem('snakeAccount'); if(data) account = JSON.parse(data); if(!account.achievements) account.achievements = {}; accountCodeBox.value = encodeAccount(account); highscoreDiv.textContent = 'Highscore: '+account.highscore; }

  // --- RESIZE & INIT
  function resize(){
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    columns = Math.floor(width / CELL_SIZE);
    rows = Math.floor(height / CELL_SIZE);
  }

  function resetGame(){
    resize(); // ensure grid set
    snakeColor = (document.body.classList.contains('light-theme') ? '#007700' : 'green');
    powerupActive = false; powerupType = ""; powerupEndTime = 0; powerupBarContainer.style.display = 'none';
    scoreMultiplier = 1; invincible = false;
    gameOver = false; gamePaused = false;
    updateDelay = BASE_UPDATE_DELAY; lastUpdateTime = 0;
    direction = nextDirection = 'Right';
    score = 0; scoreDiv.textContent = 'Score: '+score;
    // init snake in center
    const startX = Math.floor(columns/2), startY = Math.floor(rows/2);
    snake = [{x:startX,y:startY},{x:startX-1,y:startY},{x:startX-2,y:startY}];
    placeFood();
    gameOverDiv.style.display = 'none';
  }

  // --- FOOD & POWERUPS
  function placeFood(){
    // find a free cell
    for(let attempts=0; attempts<10000; attempts++){
      const x = Math.floor(Math.random()*columns);
      const y = Math.floor(Math.random()*rows);
      if(!snake.some(s=>s.x===x && s.y===y)){
        food = { x, y };
        // spawn according to PROB
        const r = Math.random();
        if(r < PROB.orange) foodIsPowerup = 'orange';
        else if(r < PROB.orange + PROB.half) foodIsPowerup = 'half';
        else if(r < PROB.orange + PROB.half + PROB.inv) foodIsPowerup = 'inv';
        else if(r < PROB.orange + PROB.half + PROB.inv + PROB.score) foodIsPowerup = 'score';
        else foodIsPowerup = false;
        return;
      }
    }
    // fallback (shouldn't happen)
    food = { x:0, y:0 }; foodIsPowerup = false;
  }

  function activatePowerup(type){
    powerupActive = true;
    powerupType = type;
    powerupEndTime = Date.now() + POWERUP_DURATIONS[type];
    powerupBarContainer.style.display = 'block';
    // set visuals & effects
    if(type === 'orange'){
      snakeColor = 'orange';
      scoreMultiplier = 1;
      invincible = false;
      updateDelay = BASE_UPDATE_DELAY;
      powerupBar.style.backgroundColor = 'orange';
    } else if(type === 'half'){
      snakeColor = 'blue';
      scoreMultiplier = 1;
      invincible = false;
      updateDelay = BASE_UPDATE_DELAY * 2; // half speed => bigger delay
      powerupBar.style.backgroundColor = 'blue';
    } else if(type === 'inv'){
      snakeColor = 'cyan';
      scoreMultiplier = 1;
      invincible = true;
      updateDelay = BASE_UPDATE_DELAY;
      powerupBar.style.backgroundColor = 'cyan';
    } else if(type === 'score'){
      snakeColor = 'magenta';
      scoreMultiplier = 5;
      invincible = false;
      updateDelay = BASE_UPDATE_DELAY;
      powerupBar.style.backgroundColor = 'magenta';
    }
  }

  function deactivatePowerup(){
    powerupActive = false;
    powerupType = "";
    powerupEndTime = 0;
    scoreMultiplier = 1;
    invincible = false;
    updateDelay = BASE_UPDATE_DELAY;
    powerupBarContainer.style.display = 'none';
    // restore snake color based on theme
    snakeColor = (document.body.classList.contains('light-theme') ? '#007700' : 'green');
  }

  // --- DRAWING
  function drawCell(x,y,color){
    ctx.fillStyle = color;
    ctx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    ctx.strokeStyle = document.body.classList.contains('light-theme') ? '#ccc' : '#222';
    ctx.lineWidth = 1;
    ctx.strokeRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }

  function drawGrid(){
    ctx.strokeStyle = document.body.classList.contains('light-theme') ? '#ddd' : '#222';
    ctx.lineWidth = 1;
    for(let gx=0; gx<=columns; gx++){
      ctx.beginPath(); ctx.moveTo(gx*CELL_SIZE, 0); ctx.lineTo(gx*CELL_SIZE, rows*CELL_SIZE); ctx.stroke();
    }
    for(let gy=0; gy<=rows; gy++){
      ctx.beginPath(); ctx.moveTo(0, gy*CELL_SIZE); ctx.lineTo(columns*CELL_SIZE, gy*CELL_SIZE); ctx.stroke();
    }
  }

  function draw(){
    ctx.clearRect(0,0,width,height);
    if(showGrid) drawGrid();

    // draw food (different color if powerup)
    const foodColor = foodIsPowerup ? (foodIsPowerup === 'orange' ? 'orange' : (foodIsPowerup === 'half' ? 'blue' : (foodIsPowerup === 'inv' ? 'cyan' : 'magenta'))) : 'red';
    if(food) drawCell(food.x, food.y, foodColor);

    // draw snake
    snake.forEach((seg, i) => {
      const color = (i===0) ? 'lime' : snakeColor;
      // visual for invincibility: slightly transparent head/body
      if(powerupActive && powerupType === 'inv') {
        ctx.globalAlpha = 0.7;
        drawCell(seg.x, seg.y, color);
        ctx.globalAlpha = 1.0;
      } else {
        drawCell(seg.x, seg.y, color);
      }
    });
  }

  // --- GAME LOGIC
  function endGame(){
    gameOver = true;
    gameOverDiv.style.display = 'block';
    powerupBarContainer.style.display = 'none';
    if(score > account.highscore){
      account.highscore = score; saveAccount();
    }
  }

  function checkAchievements(){
    achievementScores.forEach(val => {
      if(score >= val && !account.achievements[val]){
        account.achievements[val] = true;
        alert('Achievement unlocked: '+val+' points!');
        saveAccount();
      }
    });
  }

  function update(timestamp){
    if(!lastUpdateTime) lastUpdateTime = timestamp;
    if(timestamp - lastUpdateTime < updateDelay){
      requestAnimationFrame(update);
      return;
    }
    lastUpdateTime = timestamp;
    if(gameOver || gamePaused){
      requestAnimationFrame(update);
      return;
    }

    // powerup timer
    if(powerupActive){
      const duration = POWERUP_DURATIONS[powerupType] || 1;
      const remaining = (powerupEndTime - Date.now()) / duration;
      if(remaining <= 0){
        deactivatePowerup();
      } else {
        powerupBar.style.width = Math.max(0, Math.min(100, remaining*100))+'%';
      }
    }

    const opposites = { Up:'Down', Down:'Up', Left:'Right', Right:'Left' };
    if(nextDirection !== opposites[direction]) direction = nextDirection;

    // move head
    const head = { ...snake[0] };
    if(direction === 'Right') head.x++;
    else if(direction === 'Left') head.x--;
    else if(direction === 'Up') head.y--;
    else if(direction === 'Down') head.y++;

    // collision (unless invincible)
    if(!invincible && (head.x < 0 || head.x >= columns || head.y < 0 || head.y >= rows || snake.some(s => s.x === head.x && s.y === head.y))){
      endGame(); requestAnimationFrame(update); return;
    }

    snake.unshift(head);

    // eat
    if(food && head.x === food.x && head.y === food.y){
      // activate powerup if food was a powerup
      if(foodIsPowerup){
        activatePowerup(foodIsPowerup);
      }
      // apply score (if score powerup active, multiplier applies)
      const gained = (powerupActive && powerupType === 'score') ? 5 : scoreMultiplier;
      score += gained;
      scoreDiv.textContent = 'Score: '+score;
      placeFood();
      checkAchievements();
    } else {
      // normal move (pop tail)
      snake.pop();
    }

    draw();
    requestAnimationFrame(update);
  }

  // --- INPUT (keyboard + swipe)
  window.addEventListener('keydown', e => {
    if(gameOver && (e.key === 'r' || e.key === 'R')) { resetGame(); return; }
    const map = { ArrowUp:'Up', ArrowDown:'Down', ArrowLeft:'Left', ArrowRight:'Right', w:'Up', s:'Down', a:'Left', d:'Right' };
    const dir = map[e.key];
    if(!dir) return;
    const opposites = { Up:'Down', Down:'Up', Left:'Right', Right:'Left' };
    if(dir !== opposites[direction]) nextDirection = dir;
  });

  let touchStartX = null, touchStartY = null, SWIPE_THRESHOLD = 30;
  canvas.addEventListener('touchstart', e => {
    if(e.touches && e.touches[0]){ touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; }
  }, {passive:true});
  canvas.addEventListener('touchend', e => {
    if(!touchStartX || !touchStartY) { touchStartX = touchStartY = null; return; }
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
    if(Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD){ touchStartX = touchStartY = null; return; }
    if(Math.abs(dx) > Math.abs(dy)){ if(dx > 0 && direction !== 'Left') nextDirection = 'Right'; else if(dx < 0 && direction !== 'Right') nextDirection = 'Left'; }
    else { if(dy > 0 && direction !== 'Up') nextDirection = 'Down'; else if(dy < 0 && direction !== 'Down') nextDirection = 'Up'; }
    touchStartX = touchStartY = null;
  }, {passive:true});

  // --- UI: buttons & modals
  settingsBtn.addEventListener('click', () => {
    settingsModal.classList.toggle('show');
    gamePaused = settingsModal.classList.contains('show');
  });
  closeSettingsBtn.addEventListener('click', () => { settingsModal.classList.remove('show'); gamePaused = false; });
  settingsModal.addEventListener('click', function(e){
    if(e.target === settingsModal){
      settingsModal.classList.remove('show');
      gamePaused = false;
    }
  });

  achievementsBtn.addEventListener('click', () => { renderAchievementsModal(); achievementsModal.classList.add('show'); gamePaused = true; });
  closeAchievementsBtn.addEventListener('click', () => { achievementsModal.classList.remove('show'); gamePaused = false; });

  difficultyButtons.forEach(btn => btn.addEventListener('click', () => {
    const v = parseInt(btn.dataset.speed, 10);
    if(!isNaN(v)){ updateDelay = v; /* set base too so half-speed behavior consistent */ }
    settingsModal.classList.remove('show'); gamePaused = false;
  }));

  themeToggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    // restore snake color to appropriate default
    snakeColor = document.body.classList.contains('light-theme') ? '#007700' : 'green';
    draw();
  });

  gridToggleBtn.addEventListener('click', () => { showGrid = !showGrid; draw(); });

  copyCodeBtn.addEventListener('click', () => {
    const code = encodeAccount(account);
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(code).catch(()=>{ accountCodeBox.select(); document.execCommand('copy'); });
    } else {
      accountCodeBox.value = code; accountCodeBox.select(); document.execCommand('copy');
    }
  });

  loadCodeBtn.addEventListener('click', () => {
    const code = prompt('Paste your account code:');
    const acc = decodeAccount(code);
    if(acc && typeof acc.highscore === 'number'){
      account = acc; if(!account.achievements) account.achievements = {}; saveAccount(); renderAchievementsModal(); alert('Account loaded!');
    } else alert('Invalid code!');
  });

  // achievements renderer
  function renderAchievementsModal(){
    const container = document.getElementById('achievements-list-modal');
    container.innerHTML = '';
    achievementScores.forEach(s => {
      const div = document.createElement('div');
      const unlocked = !!account.achievements[s];
      div.textContent = s + ' points';
      div.style.color = unlocked ? 'lime' : (document.body.classList.contains('light-theme') ? '#555' : '#888');
      container.appendChild(div);
    });
  }

  // game-over click to restart
  gameOverDiv.addEventListener('click', () => { if(gameOver) resetGame(); });

  // window resize
  window.addEventListener('resize', () => { resize(); draw(); });

  // init
  function init(){
    resize();
    loadAccount();
    resetGame();
    renderAchievementsModal();
    requestAnimationFrame(update);
  }
  init();

})();
</script>
</body>
</html>
